### 引用

- 引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用
- 用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性
- 引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作
- 声明引用时，必须同时对其进行初始化
- 不能建立数组的引用
- 不能建立引用的引用，不能建立指向引用的指针。因为引用不是一种数据类型！！所以没有引用的引用，没有引用的指针



### const

- 利用const进行修饰的变量的值在程序的任意位置将不能再被修改，就如同常数一样使用

- const对象一旦创建之后其值就不能再改变，所以const对象必须初始化

- 非const变量默认为extern，要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern

- 常量引用 = 对const的引用

  ~~~cpp
  const int i = 55;
  const int &r1 = i;
  int j = 42;
  const int &r2 = j;  // 允许将const int& 绑定到一个普通int对象上
  ~~~

- 非const引用只能绑定到与该引用相同类型的对象。 const引用则可以绑定到不同但相关的类型的对象

  ~~~cpp
  double dval = 3.14;
  const int &r3 = dval;
  // 编译器会将上述代码转换为这种形式
  int temp = dval;
  const int &r3 = temp;  // r3绑定了一个临时量对象
  ~~~

- 指针与const

  - 指向const的指针（地址中所保存的值无法改变）

    ~~~cpp
    const int *p;  // int const *p;
    // 以上两种均可
    const int i = 45;
    const int *p1 = &i;
    int j = 55;
    const int *p2 = &j;  // 指向常量的指针所指对象可以是非常量
    *p1 = 20; *p2 = 30;  // 无法通过指针改变对象的值
    ~~~

  - const指针（不可改变指针）

    ~~~cpp
    int i = 3;
    int * const p = &i;  // P所指向的地址无法修改，因此必须被初始化
    *p = 5;  // 可以通过指针修改对象的值
    int j = 5;
    p = &j;  // 不可以改变指针
    ~~~

  - 顶层const

    ~~~cpp
    int i = 5;
    const int * const p = &i;
    int const * const p = &i;  // 指针和内容都不可改变
    ~~~

- const与define的区别

  const 是由编译器进行处理，执行类型检查和作用域的检查；

  define 是由预处理器进行处理，只做简单的文本替换工作而已。

#### 用法

- 修饰变量，说明该变量不可以被改变
- 修饰指针
  - 指向常量的指针
  - 指针常量
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改
- 修饰成员函数，说明该成员函数内不能修改成员变量



### static

1. static全局变量与普通的全局变量有什么区别 ?

   ​		这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

2. static局部变量和普通局部变量有什么区别 ？

   ​		把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。

3. static函数与普通函数有什么区别？

   ​		static函数与普通函数作用域不同，仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。

#### 作用

- 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值0初始化它
- 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static
- 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员
- 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员



### inline内联函数

1. 内联声明只是一种对编译器的建议，编译器是否采用内联措施由编译器自己来决定。甚至在汇编阶段或链接阶段，一些没有inline声明的函数编译器也会将它内联展开
2. 编译器的内联看起来就像是代码的复制与粘贴，这与预处理宏是很不同的：宏是强制的内联展开，可能将会污染所有的命名空间与代码，将为程序的调试带来困难
3. 所有中类中定义的函数都默认声明为inline函数，所有我们不用显示地去声明inline
4. 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
   内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
   inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

#### 优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能
4. 内联函数在运行时可调试，而宏定义不可以

#### 缺点

1. 内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。



#### C/C++内存有哪几种类型

##### C

- 堆	由malloc分配的内存块，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
- 栈    通常存放函数参数或者局部变量，由编译器自动分配释放
- 全局/静态存储区    全局变量和静态变量被分配到同一块内存中
- 常量存储区    里面存放的是常量例如字符串，不允许修改
- 程序代码区    存放2进制代码

##### C++

- 堆

- 栈

- 自由存储区    由new等分配的内存块，与堆十分相似，但是堆与自由存储区并不等价

- 全局/静态存储区

- 常量存储区

  

#### 程序编译的过程

.C文件 --> 预处理 --> .i文件 --> 编译 --> .s文件 --> 汇编 --> .o文件 --> 链接 --> 可执行文件



#### 什么是内存泄漏，如何避免

​		内存泄漏是指用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄漏

避免方式：

1. 使用的时候记得指针长度

2. malloc的时候记得free

3. 在C++中优先使用智能指针

   

#### 宏和内联函数的比较



#### C++中malloc/free和new/delete的区别

​		malloc和free是C/C++语言的标准库函数，new/delete是C++的运算符，他们都可以用于申请动态内存和释放内存。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加于malloc/free，在C++中，使用new创建一个对象，先底层调用malloc分配内存，然后new会触发构造函数，使用delete会先触发析构函数，然后底层调用free释放空间，而使用malloc则仅仅申请了一个空间，所以在C++中引入new和delete来支持面向对象。



#### 头文件中的ifndef/define/endif是干什么用的



#### 什么是拷贝构造函数，什么是深拷贝，什么是浅拷贝



#### 成员初始化列表

- 更高效：少了一次调用默认构造函数的过程
- 有些场合必须要用初始化列表：

1. 常量成员：常量只能初始化不能赋值，所以必须放在初始化列表里面
2. 引用类型：引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化



#### 智能指针

​		动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄漏；有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针。

​		为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针类型来管理动态对象。

- shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在“最后一个reference被销毁”时释放
- unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免内存泄漏特别有用。



#### 多态

​		多态是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称之为多态。

​		多态是以封装和继承为基础的

​		C++多态分类及实现：

1. 重载多态（编译期）：函数重载、运算符重载
2. 子类型多态（运行期）：虚函数
3. 参数多态性（编译期）：类模板、函数模板
4. 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

- 静态多态（编译期/早绑定）函数重载
- 动态多态（运行期/晚绑定） 虚函数
  - 普通函数（非类成员函数）不能是虚函数
  - 静态函数（static）不能是虚函数
  - 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）
  - 内联函数不能是表现多态性时的虚函数



#### 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的花，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面也可以不重载；但纯虚函数必须在子类去实现
- 虚函数的类用作“实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成
- 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类
- 虚基类是虚继承中的基类
- 引入虚函数是为了动态绑定；引入纯虚函数是为了派生接口



#### 虚函数表、多态的实现机制

当通过指针访问类的成员函数时：

- 如果该函数是非虚函数，那么编译器会根据指针的类型找到该函数；也就是说，指针是哪个类的类型就调用哪个类的函数
- 如果该函数是虚函数，并且派生类有同名的函数override它，那么编译器会根据指针的指向找到该函数；也就是说，指针指向的对象属于哪个类就调用哪个类的函数，这就是多态；

编译器之所以能通过指针指向的对象找到虚函数，是因为在创建对象时额外地增加了虚函数表。如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。



#### 静态绑定和动态绑定

- 静态绑定

  一般情况下，在编译期间（包括链接期间）就能找到函数名对应地地址，完成函数地绑定，程序运行后直接使用这个地址即可；这称为静态绑定

- 动态绑定

  但是有时候在编译期间想尽所有办法都不能确定使用哪个函数，必须要等到程序运行后根据具体的环境或者用户操作才能决定；这称为动态绑定



#### 设计模式

